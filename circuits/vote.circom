pragma circom 2.0.0;

// Assuming circomlib is in node_modules at the project root
// Adjust path if circomlib is installed elsewhere or globally
include "../../node_modules/circomlib/circuits/merkle.circom";
include "../../node_modules/circomlib/circuits/poseidon.circom";
include "../../node_modules/circomlib/circuits/comparators.circom";

/*
    NOTE ON HASHING CONSISTENCY:
    The JavaScript code used for client-side calculations (e.g., in zkService.js)
    and backend Merkle tree generation (e.g., in merkleTreeUtils.js) MUST use
    the exact same Poseidon hash implementation and parameters as used in this Circom circuit.
    This includes:
    1. Hashing `voterIdentifier` to create Merkle tree leaves.
    2. Calculating `nullifierHash` from `Hash(voterSecret, electionId)`.
    3. Calculating `voteCommitment` from `Hash(candidateId, voteNonce)`.
    In JavaScript, a library like 'poseidon-encryption' or 'circomlibjs' would be used.
    Ensure that the number of inputs, t, f, p, C, and M constants for Poseidon match.
*/

// vote.circom
// Verifies that a voter is registered (via Merkle proof), has not voted before (via nullifier),
// and that their vote commitment corresponds to their claimed vote.
template Vote(levels) { // Merkle Tree Depth passed as a parameter
    // --- Private Inputs ---
    signal input voterSecret;        // Voter's unique secret (e.g., derived from a private key)
    signal input voterIdentifier;    // Voter's registered identifier (this is what's hashed to form the leaf)
    signal input merklePath[levels]; // Array of sibling hashes for Merkle proof
    signal input merklePathIndices[levels]; // Array of 0s/1s indicating sibling position (0: sibling is right, 1: sibling is left)
    signal input candidateId;        // The ID of the candidate being voted for
    signal input voteNonce;          // A random nonce to ensure vote commitment uniqueness
    signal input electionId;         // ID of the election (private input, used for nullifier)

    // --- Public Inputs ---
    // These are the inputs that the Verifier smart contract will receive.
    signal input merkleRoot;         // Root of the Merkle tree of registered voterIdentifiers
    signal input nullifierHash;      // Public nullifier to prevent double-voting: Poseidon(voterSecret, electionId)
    signal input voteCommitment;     // Public commitment to the vote: Poseidon(candidateId, voteNonce)

    // --- Witness Generation and Constraints ---

    // 1. Calculate Leaf: Hash(voterIdentifier)
    //    Poseidon(1) hashes one input.
    component leafHasher = Poseidon(1);
    leafHasher.inputs[0] <== voterIdentifier;
    signal leaf <== leafHasher.out;

    // 2. Verify Merkle Proof for the calculated leaf
    //    The MerkleTreeChecker will internally use the same hash (Poseidon) as specified by circomlib's implementation.
    //    It constrains that the calculated root from the leaf and path matches the public merkleRoot.
    component merkleProofChecker = MerkleTreeChecker(levels);
    merkleProofChecker.leaf <== leaf;
    merkleProofChecker.root <== merkleRoot; // This is a constraint: calculated_root === merkleRoot
    for (var i = 0; i < levels; i++) {
        merkleProofChecker.path_elements[i] <== merklePath[i];
        // path_index in MerkleTreeChecker: 0 if element is on the left, 1 if on the right
        // This needs to align with how merklePathIndices is generated by the client/backend.
        // If merklePathIndices[i] = 0 means sibling is on the right (current path element is left child)
        // If merklePathIndices[i] = 1 means sibling is on the left (current path element is right child)
        merkleProofChecker.path_index[i] <== merklePathIndices[i];
    }

    // 3. Verify Nullifier Hash: nullifierHash === Poseidon(voterSecret, electionId)
    //    Poseidon(2) hashes two inputs.
    component nullifierHasher = Poseidon(2);
    nullifierHasher.inputs[0] <== voterSecret;
    nullifierHasher.inputs[1] <== electionId;
    signal calculatedNullifierHash <== nullifierHasher.out;

    // Constraint: calculatedNullifierHash must equal the public nullifierHash
    calculatedNullifierHash === nullifierHash;

    // 4. Verify Vote Commitment: voteCommitment === Poseidon(candidateId, voteNonce)
    //    Poseidon(2) hashes two inputs.
    component commitmentHasher = Poseidon(2);
    commitmentHasher.inputs[0] <== candidateId;
    commitmentHasher.inputs[1] <== voteNonce;
    signal calculatedVoteCommitment <== commitmentHasher.out;

    // Constraint: calculatedVoteCommitment must equal the public voteCommitment
    calculatedVoteCommitment === voteCommitment;

    // Optional: Add constraints for candidateId if a maximum number of candidates can be assumed.
    // For example, if candidateId must be less than 100:
    // component candidateRangeCheck = LessThan(252); // Max bits for field element comparison
    // candidateRangeCheck.in[0] <== candidateId;
    // candidateRangeCheck.in[1] <== 100;
    // candidateRangeCheck.out === 1;
}

// Instantiate the main component with a specific tree depth.
// Tree depth for up to 2^20 voters (approx 1 million).
parameter TREE_LEVELS = 20;

// The public inputs for the Verifier contract are merkleRoot, nullifierHash, voteCommitment.
// electionId is a private input to the circuit, used in nullifier calculation.
component main {public [merkleRoot, nullifierHash, voteCommitment]} = Vote(TREE_LEVELS);
